# Schema mode without `schema` keyword outputs single schema instead of array

## Symptom

When compiling `status_schema.avdl` (which has no `schema` keyword,
just a bare `namespace` + named type declarations), the output is a
single JSON object:

    {"type": "enum", "name": "Status", ...}

The Java tools output a JSON array of all named schemas:

    [{"type": "enum", "name": "Status", "namespace": "system", ...}]

## Root cause

In `src/reader.rs` lines 260-267, when there is no
`mainSchemaDeclaration` in the grammar, the Rust code returns the last
registered schema as the "main" schema:

```rust
if let Some(last_schema) = registry.last() {
    return Ok(IdlFile::SchemaFile(last_schema.clone()));
}
```

Then in `src/main.rs` lines 99-102, `SchemaFile` serializes that single
schema:

```rust
IdlFile::SchemaFile(schema) => {
    let empty_lookup = SchemaLookup::new();
    schema_to_json(schema, &mut IndexSet::new(), None, &empty_lookup)
}
```

The Java `IdlFile.outputString()` method (line 155-164) has different
behavior: when `mainSchema` is null and `protocol` is null, it iterates
all named schemas from the `ParseContext` and wraps them in a JSON
array.

Meanwhile, `IdlTool` (line 88) uses `m.toString(true)` when
`mainSchema` is non-null. For files without a `schema` keyword,
`getMainSchema()` returns null, so `IdlTool` falls back to
`p.toString(true)` -- but `getProtocol()` also returns null for schema-
mode files, so the tool errors out. The golden `.avsc` files for bare-
named-type files (like `status.avsc`) are generated by the test harness
via `IdlFile.outputString()`, not by `IdlTool` directly.

## Affected files

- `src/reader.rs:260-267` -- `IdlFile::SchemaFile` wraps a single
  schema, should support wrapping all named schemas in an array
- `src/main.rs:99-102` -- serialization path for `SchemaFile` does not
  account for the array-of-named-schemas case

## Reproduction

```sh
cargo run -- idl avro/lang/java/idl/src/test/idl/input/status_schema.avdl
```

Expected output (matching `status.avsc`):

```json
[
  {
    "type": "enum",
    "name": "Status",
    "namespace": "system",
    "symbols": ["UNKNOWN", "NEW", "STARTUP", "RUNNING", "TERMINATING", "SHUTDOWN", "CRASHED"],
    "default": "UNKNOWN"
  }
]
```

Actual output:

```json
{
  "default": "UNKNOWN",
  "name": "Status",
  "symbols": ["UNKNOWN", "NEW", "STARTUP", "RUNNING", "TERMINATING", "SHUTDOWN", "CRASHED"],
  "type": "enum"
}
```

## Suggested fix

Introduce a new `IdlFile` variant (e.g., `NamedSchemasFile`) or change
`SchemaFile` to carry `Vec<AvroSchema>` for the bare-named-types case.
When serializing, iterate all named schemas from the registry and wrap
them in a `Value::Array`. The existing `SchemaFile(schema)` variant can
continue to handle the `schema <type>;` case.
